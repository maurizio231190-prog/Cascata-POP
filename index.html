<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Coniglio & Fiamme</title>
  <style>
    html, body { margin:0; padding:0; height:100%; background:#0b0b10; overflow:hidden; }
    canvas { display:block; width:100vw; height:100vh; touch-action:none; }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<script>
(() => {
  // =========================
  // Fullscreen Canvas
  // =========================
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });

  const DPR = Math.min(2, window.devicePixelRatio || 1);
  function resize() {
    canvas.width = Math.floor(innerWidth * DPR);
    canvas.height = Math.floor(innerHeight * DPR);
  }
  addEventListener('resize', resize);
  resize();

  // =========================
  // Helpers
  // =========================
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a, b, t) => a + (b - a) * t;
  const rand = (a, b) => a + Math.random() * (b - a);
  const randi = (a, b) => Math.floor(rand(a, b + 1));

  function dist2(ax, ay, bx, by) {
    const dx = ax - bx, dy = ay - by;
    return dx * dx + dy * dy;
  }

  // =========================
  // Sound (procedural WebAudio)
  // =========================
  class SoundBank {
    constructor() {
      this.ctx = null;
      this.master = null;
      this.enabled = true;
      this.cool = new Map(); // key -> time
    }
    ensure() {
      if (this.ctx) return;
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      if (!AudioCtx) { this.enabled = false; return; }
      this.ctx = new AudioCtx();
      this.master = this.ctx.createGain();
      this.master.gain.value = 0.25;
      this.master.connect(this.ctx.destination);
    }
    now() { return this.ctx ? this.ctx.currentTime : 0; }
    can(key, ms) {
      const t = performance.now();
      const last = this.cool.get(key) || 0;
      if (t - last < ms) return false;
      this.cool.set(key, t);
      return true;
    }
    tone({freq=440, dur=0.12, type='sine', gain=0.08, detune=0, slideTo=null} = {}) {
      if (!this.enabled) return;
      this.ensure();
      if (!this.ctx) return;
      const t0 = this.now();
      const o = this.ctx.createOscillator();
      const g = this.ctx.createGain();
      o.type = type;
      o.frequency.setValueAtTime(freq, t0);
      if (slideTo) o.frequency.exponentialRampToValueAtTime(slideTo, t0 + dur);
      o.detune.setValueAtTime(detune, t0);
      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(gain, t0 + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
      o.connect(g); g.connect(this.master);
      o.start(t0);
      o.stop(t0 + dur + 0.02);
    }
    pop() {
      if (!this.can('pop', 45)) return;
      // piccolo "pop" buffo
      this.tone({freq: rand(250, 360), dur: 0.06, type:'triangle', gain: 0.06, slideTo: rand(140, 220)});
      this.tone({freq: rand(900, 1200), dur: 0.04, type:'sine', gain: 0.03, detune: rand(-8, 8)});
    }
    starNote(step=0) {
      if (!this.can('star', 35)) return;
      // scala felice, con micro-variazioni
      const scale = [0,2,4,7,9,12,14,16]; // maggiore-ish
      const base = 440 * Math.pow(2, -1); // A3
      const semi = scale[step % scale.length] + (Math.random() < 0.08 ? 12 : 0);
      const f = base * Math.pow(2, semi/12);
      this.tone({freq: f * rand(0.98, 1.02), dur: 0.09, type:'sine', gain: 0.07});
      this.tone({freq: f*2 * rand(0.99, 1.01), dur: 0.06, type:'triangle', gain: 0.035, detune: rand(-5,5)});
    }
    jingle(kind='c3') {
      // mini-melodie: 3/5/10 combo
      const key = 'jing'+kind;
      if (!this.can(key, 120)) return;
      const t0 = this.now();
      const mk = (f, dt, dur, g, type='sine') => {
        const o = this.ctx.createOscillator();
        const ga = this.ctx.createGain();
        o.type = type;
        o.frequency.setValueAtTime(f, t0 + dt);
        ga.gain.setValueAtTime(0.0001, t0 + dt);
        ga.gain.exponentialRampToValueAtTime(g, t0 + dt + 0.01);
        ga.gain.exponentialRampToValueAtTime(0.0001, t0 + dt + dur);
        o.connect(ga); ga.connect(this.master);
        o.start(t0 + dt);
        o.stop(t0 + dt + dur + 0.02);
      };
      const base = 330;
      const seq = kind==='c10'
        ? [0,4,7,12,7,16,12]
        : kind==='c5'
          ? [0,4,7,12]
          : [0,7,12];
      seq.forEach((s, i) => {
        const f = base * Math.pow(2, s/12) * rand(0.995,1.005);
        mk(f, i*0.08, 0.09, 0.06, i%2? 'triangle':'sine');
      });
    }
    teacher() {
      if (!this.can('teacher', 140)) return;
      // megafono/wa-wa comico (non aggressivo)
      const t0 = this.now();
      const o = this.ctx.createOscillator();
      const lfo = this.ctx.createOscillator();
      const lfoG = this.ctx.createGain();
      const g = this.ctx.createGain();
      o.type = 'square';
      o.frequency.setValueAtTime(rand(180, 260), t0);
      lfo.type = 'sine';
      lfo.frequency.setValueAtTime(rand(7, 10), t0);
      lfoG.gain.setValueAtTime(rand(25, 45), t0);
      lfo.connect(lfoG);
      lfoG.connect(o.frequency);

      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(0.09, t0 + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.22);

      o.connect(g); g.connect(this.master);
      lfo.start(t0); o.start(t0);
      lfo.stop(t0 + 0.25); o.stop(t0 + 0.25);
    }
    grandpa() {
      if (!this.can('grandpa', 140)) return;
      // brontolio buffo
      this.tone({freq: rand(70, 95), dur: 0.22, type:'sawtooth', gain: 0.06, slideTo: rand(55, 75)});
      this.tone({freq: rand(120, 150), dur: 0.14, type:'triangle', gain: 0.03, detune: rand(-12,12)});
    }
    animal() {
      if (!this.can('animal', 90)) return;
      // chirp dolce / miao sintetico
      this.tone({freq: rand(520, 740), dur: 0.10, type:'sine', gain: 0.06, slideTo: rand(900, 1200)});
      if (Math.random() < 0.35) this.tone({freq: rand(260, 380), dur: 0.09, type:'triangle', gain: 0.03, slideTo: rand(220, 300)});
    }
    pizza() {
      if (!this.can('pizza', 180)) return;
      // ta-daa + crunch soft
      this.tone({freq: 440, dur: 0.10, type:'triangle', gain: 0.07, slideTo: 660});
      this.tone({freq: 660, dur: 0.10, type:'sine', gain: 0.06, slideTo: 880});
      if (Math.random() < 0.6) this.tone({freq: rand(110, 160), dur: 0.09, type:'square', gain: 0.03, detune: rand(-7,7)});
    }
    flameNear(intensity=0.0) {
      // tensione leggera: poco frequente
      if (intensity < 0.65) return;
      if (!this.can('flame', 160)) return;
      this.tone({freq: rand(140, 190), dur: 0.16, type:'sine', gain: 0.025, slideTo: rand(190, 240)});
    }
  }

  const SND = new SoundBank();

  // =========================
  // Visual style (minimal manga)
  // =========================
  const PAL = {
    bgTop: '#0b0b10',
    bgBot: '#10101a',
    ink: 'rgba(0,0,0,0.85)',
    white: '#f4f5ff',
    star: '#ffe37a',
    star2: '#fff3b8',
    bunny: '#f2f2f7',
    bunny2: '#d9d9e6',
    flame1: '#ff6a3a',
    flame2: '#ffd36a',
    bubble: 'rgba(250,250,255,0.92)',
    bubble2: 'rgba(240,240,255,0.90)',
    teacher: '#ff7aa6',
    grandpa: '#9de0ff',
    animal: '#a8ffb6',
    pizza: '#ffcf6e'
  };

  function roundRectPath(ctx, x, y, w, h, r) {
    r = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
  }

  // Bubble types: 'oval', 'cloud', 'spiky'
  function drawBubble(ctx, x, y, r, type='oval') {
    ctx.save();
    const lw = Math.max(2, r * 0.12);
    ctx.lineWidth = lw;
    ctx.fillStyle = PAL.bubble;
    ctx.strokeStyle = PAL.ink;

    if (type === 'oval') {
      ctx.beginPath();
      ctx.ellipse(x, y, r*1.12, r*0.92, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();
    } else if (type === 'cloud') {
      // nuvoletta: 5 cerchi
      const rr = r*0.55;
      ctx.beginPath();
      ctx.ellipse(x - r*0.55, y, rr, rr, 0, 0, Math.PI*2);
      ctx.ellipse(x - r*0.15, y - r*0.30, rr*1.02, rr*1.02, 0, 0, Math.PI*2);
      ctx.ellipse(x + r*0.35, y - r*0.05, rr*1.05, rr*1.05, 0, 0, Math.PI*2);
      ctx.ellipse(x + r*0.65, y + r*0.18, rr*0.90, rr*0.90, 0, 0, Math.PI*2);
      ctx.ellipse(x, y + r*0.38, rr*1.10, rr*0.90, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();
    } else { // spiky
      const spikes = 12;
      const inner = r*0.90;
      const outer = r*1.15;
      ctx.beginPath();
      for (let i=0;i<spikes;i++) {
        const a = (i/spikes) * Math.PI*2;
        const rr = (i % 2 === 0) ? outer : inner;
        const px = x + Math.cos(a) * rr;
        const py = y + Math.sin(a) * rr;
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
    }

    // micro highlight
    ctx.globalAlpha = 0.14;
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.ellipse(x - r*0.35, y - r*0.35, r*0.55, r*0.35, -0.6, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  }

  function drawKawaiiEyes(ctx, x, y, s) {
    ctx.save();
    ctx.fillStyle = PAL.ink;
    ctx.beginPath(); ctx.ellipse(x - s*0.45, y, s*0.15, s*0.22, 0, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(x + s*0.45, y, s*0.15, s*0.22, 0, 0, Math.PI*2); ctx.fill();
    // sparkle
    ctx.fillStyle = 'rgba(255,255,255,0.85)';
    ctx.beginPath(); ctx.ellipse(x - s*0.52, y - s*0.06, s*0.06, s*0.06, 0, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(x + s*0.38, y - s*0.06, s*0.05, s*0.05, 0, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }

  function drawStarIcon(ctx, x, y, r, pulse=0) {
    ctx.save();
    const s = r * (1 + pulse*0.06);
    ctx.fillStyle = PAL.star;
    ctx.strokeStyle = PAL.ink;
    ctx.lineWidth = Math.max(2, r*0.12);

    // stella cicciotta
    ctx.beginPath();
    const points = 5;
    const outer = s*0.72;
    const inner = s*0.34;
    for (let i=0;i<points*2;i++) {
      const a = (i/(points*2))*Math.PI*2 - Math.PI/2;
      const rr = (i%2===0) ? outer : inner;
      const px = x + Math.cos(a)*rr;
      const py = y + Math.sin(a)*rr;
      if (i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
    }
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    // faccina
    drawKawaiiEyes(ctx, x, y + s*0.06, s*0.60);
    ctx.strokeStyle = PAL.ink;
    ctx.lineWidth = Math.max(2, r*0.10);
    ctx.beginPath();
    ctx.arc(x, y + s*0.20, s*0.18, 0, Math.PI);
    ctx.stroke();

    ctx.restore();
  }

  function drawPizzaIcon(ctx, x, y, r, pulse=0) {
    ctx.save();
    const s = r * (1 + pulse*0.06);
    ctx.fillStyle = PAL.pizza;
    ctx.strokeStyle = PAL.ink;
    ctx.lineWidth = Math.max(2, r*0.12);

    // fetta triangolo
    ctx.beginPath();
    ctx.moveTo(x, y - s*0.70);
    ctx.lineTo(x - s*0.55, y + s*0.55);
    ctx.lineTo(x + s*0.55, y + s*0.55);
    ctx.closePath();
    ctx.fill(); ctx.stroke();

    // crosta
    ctx.fillStyle = '#ffb85c';
    ctx.beginPath();
    ctx.moveTo(x, y - s*0.70);
    ctx.quadraticCurveTo(x - s*0.35, y - s*0.45, x - s*0.55, y + s*0.55);
    ctx.quadraticCurveTo(x, y + s*0.35, x + s*0.55, y + s*0.55);
    ctx.quadraticCurveTo(x + s*0.35, y - s*0.45, x, y - s*0.70);
    ctx.closePath();
    ctx.fill(); ctx.stroke();

    // salamini
    ctx.fillStyle = '#ff6a6a';
    ctx.beginPath(); ctx.ellipse(x - s*0.18, y + s*0.05, s*0.14, s*0.14, 0, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(x + s*0.18, y + s*0.15, s*0.14, s*0.14, 0, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = 'rgba(0,0,0,0.45)';
    ctx.lineWidth = Math.max(1, r*0.06);
    ctx.stroke();

    ctx.restore();
  }

  function drawAnimalIcon(ctx, x, y, r, pulse=0) {
    ctx.save();
    const s = r * (1 + pulse*0.06);
    const lw = Math.max(2, r*0.12);
    ctx.lineWidth = lw;
    ctx.fillStyle = PAL.animal;
    ctx.strokeStyle = PAL.ink;

    // testa tonda
    ctx.beginPath();
    ctx.ellipse(x, y, s*0.70, s*0.62, 0, 0, Math.PI*2);
    ctx.fill(); ctx.stroke();

    // orecchie
    ctx.beginPath();
    ctx.ellipse(x - s*0.45, y - s*0.50, s*0.20, s*0.28, -0.25, 0, Math.PI*2);
    ctx.ellipse(x + s*0.45, y - s*0.50, s*0.20, s*0.28, 0.25, 0, Math.PI*2);
    ctx.fill(); ctx.stroke();

    drawKawaiiEyes(ctx, x, y - s*0.05, s*0.70);

    // nasino
    ctx.fillStyle = PAL.ink;
    ctx.beginPath();
    ctx.ellipse(x, y + s*0.18, s*0.10, s*0.08, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  }

  function drawTeacherIcon(ctx, x, y, r, pulse=0) {
    ctx.save();
    const s = r * (1 + pulse*0.05);
    const lw = Math.max(2, r*0.12);
    ctx.lineWidth = lw;
    ctx.strokeStyle = PAL.ink;

    // testa
    ctx.fillStyle = '#ffd7e5';
    ctx.beginPath();
    ctx.ellipse(x, y, s*0.70, s*0.66, 0, 0, Math.PI*2);
    ctx.fill(); ctx.stroke();

    // chignon
    ctx.fillStyle = PAL.teacher;
    ctx.beginPath();
    ctx.ellipse(x + s*0.60, y - s*0.55, s*0.20, s*0.20, 0, 0, Math.PI*2);
    ctx.fill(); ctx.stroke();

    // occhiali
    ctx.save();
    ctx.lineWidth = Math.max(1.5, lw*0.75);
    ctx.strokeStyle = PAL.ink;
    ctx.beginPath();
    ctx.ellipse(x - s*0.28, y - s*0.05, s*0.22, s*0.18, 0, 0, Math.PI*2);
    ctx.ellipse(x + s*0.28, y - s*0.05, s*0.22, s*0.18, 0, 0, Math.PI*2);
    ctx.moveTo(x - s*0.06, y - s*0.05);
    ctx.lineTo(x + s*0.06, y - s*0.05);
    ctx.stroke();
    ctx.restore();

    // occhi
    ctx.fillStyle = PAL.ink;
    ctx.beginPath(); ctx.ellipse(x - s*0.28, y - s*0.05, s*0.07, s*0.11, 0, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(x + s*0.28, y - s*0.05, s*0.07, s*0.11, 0, 0, Math.PI*2); ctx.fill();

    // bocca "O" urlo
    ctx.fillStyle = '#ff4b4b';
    ctx.beginPath();
    ctx.ellipse(x, y + s*0.30, s*0.18, s*0.22, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = 'rgba(0,0,0,0.55)';
    ctx.lineWidth = Math.max(1.5, lw*0.6);
    ctx.stroke();

    // onde sonore (archi)
    ctx.save();
    ctx.strokeStyle = PAL.ink;
    ctx.lineWidth = Math.max(2, lw*0.65);
    const ox = x + s*0.80;
    const oy = y + s*0.10;
    for (let i=0;i<3;i++) {
      const rr = s*(0.18 + i*0.14);
      ctx.beginPath();
      ctx.arc(ox, oy, rr, -0.6, 0.6);
      ctx.stroke();
    }
    ctx.restore();

    ctx.restore();
  }

  function drawGrandpaIcon(ctx, x, y, r, pulse=0) {
    ctx.save();
    const s = r * (1 + pulse*0.05);
    const lw = Math.max(2, r*0.12);
    ctx.lineWidth = lw;
    ctx.strokeStyle = PAL.ink;

    // testa
    ctx.fillStyle = '#d6f3ff';
    ctx.beginPath();
    ctx.ellipse(x, y, s*0.72, s*0.66, 0, 0, Math.PI*2);
    ctx.fill(); ctx.stroke();

    // sopracciglia a V
    ctx.save();
    ctx.strokeStyle = PAL.ink;
    ctx.lineWidth = Math.max(2, lw*0.70);
    ctx.beginPath();
    ctx.moveTo(x - s*0.55, y - s*0.20);
    ctx.lineTo(x - s*0.18, y - s*0.35);
    ctx.moveTo(x + s*0.55, y - s*0.20);
    ctx.lineTo(x + s*0.18, y - s*0.35);
    ctx.stroke();
    ctx.restore();

    // occhi
    ctx.fillStyle = PAL.ink;
    ctx.beginPath(); ctx.ellipse(x - s*0.25, y - s*0.05, s*0.08, s*0.10, 0, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(x + s*0.25, y - s*0.05, s*0.08, s*0.10, 0, 0, Math.PI*2); ctx.fill();

    // baffo (due archi)
    ctx.save();
    ctx.strokeStyle = PAL.ink;
    ctx.lineWidth = Math.max(2, lw*0.75);
    ctx.beginPath();
    ctx.arc(x - s*0.15, y + s*0.20, s*0.22, 0.1, Math.PI - 0.1);
    ctx.arc(x + s*0.15, y + s*0.20, s*0.22, 0.1, Math.PI - 0.1);
    ctx.stroke();
    ctx.restore();

    // bocca arrabbiata
    ctx.save();
    ctx.strokeStyle = PAL.ink;
    ctx.lineWidth = Math.max(2, lw*0.6);
    ctx.beginPath();
    ctx.arc(x, y + s*0.40, s*0.18, Math.PI, Math.PI*2);
    ctx.stroke();
    ctx.restore();

    ctx.restore();
  }

  function drawBunny(ctx, x, y, r, wiggle=0) {
    ctx.save();
    const lw = Math.max(2, r*0.10);
    ctx.lineWidth = lw;
    ctx.strokeStyle = PAL.ink;

    // corpo
    ctx.fillStyle = PAL.bunny;
    ctx.beginPath();
    ctx.ellipse(x, y + r*0.25, r*0.85, r*0.75, 0, 0, Math.PI*2);
    ctx.fill(); ctx.stroke();

    // testa
    ctx.beginPath();
    ctx.ellipse(x, y - r*0.15, r*0.75, r*0.68, 0, 0, Math.PI*2);
    ctx.fill(); ctx.stroke();

    // orecchie (wiggle)
    const a = wiggle * 0.35;
    ctx.fillStyle = PAL.bunny;
    ctx.beginPath();
    ctx.ellipse(x - r*0.35, y - r*0.92, r*0.22, r*0.70, -0.18 - a, 0, Math.PI*2);
    ctx.ellipse(x + r*0.35, y - r*0.92, r*0.22, r*0.70, 0.18 + a, 0, Math.PI*2);
    ctx.fill(); ctx.stroke();

    // occhi kawaii
    drawKawaiiEyes(ctx, x, y - r*0.12, r*0.85);

    // nasino
    ctx.fillStyle = PAL.ink;
    ctx.beginPath();
    ctx.ellipse(x, y + r*0.10, r*0.08, r*0.06, 0, 0, Math.PI*2);
    ctx.fill();

    // sorriso
    ctx.save();
    ctx.strokeStyle = PAL.ink;
    ctx.lineWidth = Math.max(2, lw*0.55);
    ctx.beginPath();
    ctx.arc(x, y + r*0.22, r*0.16, 0, Math.PI);
    ctx.stroke();
    ctx.restore();

    ctx.restore();
  }

  function drawFlames(ctx, yFromBottom, t, w, h) {
    // onda fiamme minimal (non realistiche)
    const baseY = h - yFromBottom;
    const amp = Math.max(10*DPR, Math.min(44*DPR, yFromBottom * 0.12));
    ctx.save();
    // gradiente caldo
    const grad = ctx.createLinearGradient(0, baseY-amp*2, 0, h);
    grad.addColorStop(0, PAL.flame2);
    grad.addColorStop(0.55, PAL.flame1);
    grad.addColorStop(1, 'rgba(255,70,20,1)');
    ctx.fillStyle = grad;

    ctx.beginPath();
    ctx.moveTo(0, h);
    ctx.lineTo(0, baseY);

    const waves = 5;
    for (let i=0;i<=waves;i++) {
      const x = (i/waves) * w;
      const s = Math.sin(t*1.4 + i*0.8) + Math.sin(t*2.1 + i*1.3)*0.5;
      const y = baseY - amp*(0.65 + 0.35*s);
      ctx.quadraticCurveTo(x - w/(waves*2), y, x, yFromBottom > 0 ? y : baseY);
    }
    ctx.lineTo(w, h);
    ctx.closePath();
    ctx.fill();

    // bordo inchiostro sopra la fiamma
    ctx.strokeStyle = 'rgba(0,0,0,0.55)';
    ctx.lineWidth = Math.max(2, 3*DPR);
    ctx.beginPath();
    for (let i=0;i<=waves;i++) {
      const x = (i/waves) * w;
      const s = Math.sin(t*1.4 + i*0.8) + Math.sin(t*2.1 + i*1.3)*0.5;
      const y = baseY - amp*(0.65 + 0.35*s);
      if (i===0) ctx.moveTo(x, y);
      else ctx.quadraticCurveTo(x - w/(waves*2), y, x, y);
    }
    ctx.stroke();

    ctx.restore();
  }

  // =========================
  // Game State
  // =========================
  const STATE = {
    IDLE: 'idle',
    PLAY: 'play',
    OVER: 'over'
  };

  const game = {
    state: STATE.IDLE,
    t: 0,
    dt: 0,
    last: performance.now(),
    shake: 0,
    shakeX: 0,
    shakeY: 0,

    // Bunny
    bunny: {
      x: 0,
      y: 0,
      r: 24*DPR,
      vx: 0,
      targetX: 0,
      wiggle: 0
    },

    // “vita” invisibile: 3 stelline vicino al coniglio
    lives: 3,

    // Combo & “musica”
    combo: 0,
    noteStep: 0,

    // Flames
    flames: 0,           // altezza fiamme (px)
    flamesSpeed: 28*DPR, // base speed
    flamesBoost: 0,      // extra temporaneo

    // Powerups
    slowUntil: 0,        // rallenta fiamme
    starRainUntil: 0,    // pioggia stelle

    // Spawner
    items: [],
    spawnTimer: 0,
    difficulty: 0
  };

  function resetToIdle() {
    game.state = STATE.IDLE;
    game.items.length = 0;
    game.lives = 3;
    game.combo = 0;
    game.noteStep = 0;
    game.flames = 0;
    game.flamesBoost = 0;
    game.slowUntil = 0;
    game.starRainUntil = 0;
    game.spawnTimer = 0;
    game.difficulty = 0;
  }

  function startGame() {
    game.state = STATE.PLAY;
    game.items.length = 0;
    game.lives = 3;
    game.combo = 0;
    game.noteStep = 0;
    game.flames = 10*DPR;
    game.flamesBoost = 0;
    game.slowUntil = 0;
    game.starRainUntil = 0;
    game.spawnTimer = 0.2;
    game.difficulty = 0;
  }

  function gameOver() {
    game.state = STATE.OVER;
    game.items.length = 0;
    game.flamesBoost = 80*DPR;
    game.shake = 0.35;
  }

  // =========================
  // Items
  // =========================
  // kind: 'star' | 'teacher' | 'grandpa' | 'animal' | 'pizza'
  function spawnItem(kind) {
    const w = canvas.width, h = canvas.height;
    const margin = 70 * DPR;
    const r = rand(22, 30) * DPR;
    const x = rand(margin, w - margin);
    const y = -r * 2;
    const speedBase = lerp(210, 340, clamp(game.difficulty, 0, 1)) * DPR;
    const speed = speedBase * rand(0.85, 1.15);

    // bubble type: buoni -> oval/cloud, cattivi -> spiky
    let bubble = 'oval';
    if (kind === 'teacher') bubble = 'spiky';
    else if (kind === 'grandpa') bubble = 'spiky';
    else if (kind === 'animal') bubble = (Math.random()<0.5 ? 'cloud' : 'oval');
    else if (kind === 'pizza') bubble = 'cloud';

    game.items.push({
      kind, x, y, r, bubble,
      speed,
      pulse: 0,
      wobble: rand(0, Math.PI*2)
    });

    SND.pop();
  }

  function spawnLogic(dt) {
    game.spawnTimer -= dt;
    if (game.spawnTimer > 0) return;

    // Più avanti = più frequente
    const base = lerp(0.60, 0.32, clamp(game.difficulty, 0, 1)); // secondi
    game.spawnTimer = base * rand(0.75, 1.25);

    // Probabilità (stella frequente, bonus rari)
    const pStar    = 0.55;
    const pTeacher = 0.22;
    const pGrandpa = 0.13;
    const pAnimal  = 0.06;
    const pPizza   = 0.04;

    const r = Math.random();
    if (r < pStar) spawnItem('star');
    else if (r < pStar + pTeacher) spawnItem('teacher');
    else if (r < pStar + pTeacher + pGrandpa) spawnItem('grandpa');
    else if (r < pStar + pTeacher + pGrandpa + pAnimal) spawnItem('animal');
    else spawnItem('pizza');

    // Star rain: aggiungi più stelle durante il powerup
    if (performance.now()/1000 < game.starRainUntil && Math.random() < 0.65) {
      spawnItem('star');
      if (Math.random() < 0.25) spawnItem('star');
    }
  }

  // =========================
  // Input (touch-only + mouse works too)
  // =========================
  let pointerDown = false;

  function pointerXFromEvent(ev) {
    const rect = canvas.getBoundingClientRect();
    const x = (('touches' in ev) ? ev.touches[0].clientX : ev.clientX) - rect.left;
    return x * DPR;
  }

  function onDown(ev) {
    ev.preventDefault();
    pointerDown = true;

    // Audio must start on user gesture
    SND.ensure();

    const x = pointerXFromEvent(ev);
    game.bunny.targetX = x;

    if (game.state === STATE.IDLE) startGame();
    else if (game.state === STATE.OVER) startGame();
  }

  function onMove(ev) {
    if (!pointerDown) return;
    ev.preventDefault();
    const x = pointerXFromEvent(ev);
    game.bunny.targetX = x;
  }

  function onUp(ev) {
    ev.preventDefault();
    pointerDown = false;
  }

  canvas.addEventListener('pointerdown', onDown, { passive: false });
  canvas.addEventListener('pointermove', onMove, { passive: false });
  canvas.addEventListener('pointerup', onUp, { passive: false });
  canvas.addEventListener('pointercancel', onUp, { passive: false });

  // =========================
  // Update
  // =========================
  function update(dt) {
    const w = canvas.width, h = canvas.height;

    // Bunny setup
    game.bunny.y = h - (120 * DPR);
    game.bunny.r = Math.max(22*DPR, Math.min(34*DPR, w*0.03));
    if (game.bunny.x === 0) {
      game.bunny.x = w/2;
      game.bunny.targetX = w/2;
    }

    // Smooth follow (drag)
    const bx = game.bunny.x;
    const tx = clamp(game.bunny.targetX, 40*DPR, w - 40*DPR);
    const ax = (tx - bx) * 22 * dt;       // “molla”
    game.bunny.vx = (game.bunny.vx + ax) * Math.pow(0.06, dt); // damping
    game.bunny.x = clamp(game.bunny.x + game.bunny.vx, 40*DPR, w - 40*DPR);
    game.bunny.wiggle = lerp(game.bunny.wiggle, clamp(game.bunny.vx * 0.02, -1, 1), 8*dt);

    // Difficulty ramp (0..1)
    if (game.state === STATE.PLAY) {
      game.difficulty = clamp(game.difficulty + dt * 0.02, 0, 1);
    }

    // Flames
    const nowSec = performance.now()/1000;
    const slow = nowSec < game.slowUntil;
    const baseSpeed = game.flamesSpeed * lerp(1.0, 1.8, game.difficulty);
    const boost = Math.max(0, game.flamesBoost);
    game.flamesBoost = Math.max(0, game.flamesBoost - 80*DPR*dt);

    let flameSpeed = baseSpeed + boost;
    if (slow) flameSpeed *= 0.55;
    game.flames += flameSpeed * dt;

    // Flame proximity sound
    const dangerLine = h - game.bunny.y;
    const intensity = clamp((game.flames - (dangerLine*0.55)) / (dangerLine*0.45), 0, 1);
    SND.flameNear(intensity);

    // Spawn + items
    if (game.state === STATE.PLAY) {
      spawnLogic(dt);
      for (let i = game.items.length - 1; i >= 0; i--) {
        const it = game.items[i];
        it.y += it.speed * dt;
        it.wobble += dt * rand(0.5, 1.2);
        it.pulse = Math.max(0, it.pulse - dt*2.5);

        // remove if off screen
        if (it.y > h + it.r*3) game.items.splice(i, 1);
      }

      // Collisions
      const br = game.bunny.r;
      const bx2 = game.bunny.x;
      const by2 = game.bunny.y;
      for (let i = game.items.length - 1; i >= 0; i--) {
        const it = game.items[i];
        const rr = (br * 0.90 + it.r * 0.95);
        if (dist2(bx2, by2, it.x, it.y) < rr*rr) {
          // hit
          game.items.splice(i, 1);
          it.pulse = 1;

          if (it.kind === 'star') {
            game.combo += 1;
            game.noteStep += 1;
            SND.starNote(game.noteStep);

            // riduci pressione fiamme (tipo “cura”)
            game.flames = Math.max(0, game.flames - (26*DPR + game.combo*0.6*DPR));

            // jingles
            if (game.combo === 3) SND.jingle('c3');
            else if (game.combo === 5) SND.jingle('c5');
            else if (game.combo === 10) SND.jingle('c10');

            // micro bounce coniglio
            game.bunny.wiggle += 0.12;

          } else if (it.kind === 'teacher') {
            // danno: fiamme su + combo rotta + shake
            game.combo = 0;
            game.flamesBoost += 120*DPR;
            game.lives -= 1;
            SND.teacher();
            game.shake = 0.22;

          } else if (it.kind === 'grandpa') {
            game.combo = 0;
            game.flamesBoost += 95*DPR;
            game.lives -= 1;
            SND.grandpa();
            game.shake = 0.18;

          } else if (it.kind === 'animal') {
            // bonus: rallenta fiamme 3 sec
            game.slowUntil = nowSec + 3.0;
            SND.animal();
            // piccolo regalo: abbassa un filo fiamme
            game.flames = Math.max(0, game.flames - 50*DPR);

          } else if (it.kind === 'pizza') {
            // bonus: pioggia stelle 2 sec
            game.starRainUntil = nowSec + 2.0;
            SND.pizza();
            // “festa”: riduci pressione e tieni combo
            game.flames = Math.max(0, game.flames - 70*DPR);
          }
        }
      }

      // Game over conditions
      if (game.lives <= 0) {
        gameOver();
      } else {
        // fiamme raggiungono coniglio
        const bunnyFromBottom = h - game.bunny.y + br*0.45;
        if (game.flames >= bunnyFromBottom) gameOver();
      }
    }

    // Screen shake decay
    game.shake = Math.max(0, game.shake - dt*1.5);
    if (game.shake > 0) {
      const mag = (12*DPR) * game.shake;
      game.shakeX = rand(-mag, mag);
      game.shakeY = rand(-mag, mag);
    } else {
      game.shakeX = 0; game.shakeY = 0;
    }
  }

  // =========================
  // Draw
  // =========================
  function drawBackground(w, h, t) {
    // semplice gradiente + linee manga leggere
    const g = ctx.createLinearGradient(0, 0, 0, h);
    g.addColorStop(0, PAL.bgTop);
    g.addColorStop(1, PAL.bgBot);
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, w, h);

    // linee “manga” sottili in alto (molto leggere)
    ctx.save();
    ctx.globalAlpha = 0.07;
    ctx.strokeStyle = PAL.white;
    ctx.lineWidth = Math.max(1, 1.5*DPR);
    const lines = 10;
    for (let i=0;i<lines;i++) {
      const y = (i/lines) * h * 0.55 + (Math.sin(t*0.6+i)*6*DPR);
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(w, y - rand(0, 18*DPR));
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawLivesNearBunny() {
    // 3 mini-stelline vicino al coniglio (non UI, sta “nel mondo”)
    const x = game.bunny.x;
    const y = game.bunny.y + game.bunny.r*1.00;
    const r = game.bunny.r*0.22;
    for (let i=0;i<3;i++) {
      ctx.save();
      ctx.globalAlpha = (i < game.lives) ? 0.95 : 0.20;
      drawStarIcon(ctx, x + (i-1)*r*2.3, y, r*1.2, 0);
      ctx.restore();
    }
  }

  function drawItem(it, t) {
    const wob = Math.sin(it.wobble) * it.r*0.06;
    drawBubble(ctx, it.x + wob, it.y, it.r, it.bubble);

    const pulse = it.pulse;
    if (it.kind === 'star') drawStarIcon(ctx, it.x + wob, it.y, it.r*0.75, pulse);
    else if (it.kind === 'teacher') drawTeacherIcon(ctx, it.x + wob, it.y, it.r*0.78, pulse);
    else if (it.kind === 'grandpa') drawGrandpaIcon(ctx, it.x + wob, it.y, it.r*0.78, pulse);
    else if (it.kind === 'animal') drawAnimalIcon(ctx, it.x + wob, it.y, it.r*0.78, pulse);
    else if (it.kind === 'pizza') drawPizzaIcon(ctx, it.x + wob, it.y, it.r*0.78, pulse);
  }

  function render() {
    const w = canvas.width, h = canvas.height;
    ctx.save();
    ctx.translate(game.shakeX, game.shakeY);

    drawBackground(w, h, game.t);

    // items
    for (const it of game.items) drawItem(it, game.t);

    // bunny
    drawBunny(ctx, game.bunny.x, game.bunny.y, game.bunny.r, game.bunny.wiggle);

    // lives (in-world)
    drawLivesNearBunny();

    // flames
    drawFlames(ctx, game.flames, game.t, w, h);

    // Idle / Over: niente testo, solo un “pulsino” discreto (tap to start)
    if (game.state === STATE.IDLE || game.state === STATE.OVER) {
      ctx.save();
      ctx.globalAlpha = 0.22;
      const r = (24*DPR) + Math.sin(game.t*2.6)*4*DPR;
      drawBubble(ctx, w*0.5, h*0.22, r, 'cloud');
      // mini stella dentro per invogliare il tap
      ctx.globalAlpha = 0.55;
      drawStarIcon(ctx, w*0.5, h*0.22, r*0.55, 0);
      ctx.restore();
    }

    ctx.restore();
  }

  // =========================
  // Main Loop
  // =========================
  function loop() {
    const now = performance.now();
    const dt = Math.min(0.033, (now - game.last) / 1000);
    game.last = now;

    game.t += dt;
    update(dt);
    render();

    requestAnimationFrame(loop);
  }

  resetToIdle();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
