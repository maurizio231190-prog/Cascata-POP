<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Cascata POP - Prototype</title>
  <style>
    html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#000; touch-action:none; }
    canvas { display:block; width:100vw; height:100vh; }
  </style>
</head>
<body>
<canvas id="c"></canvas>

<script>
/**
 * PROTOTIPO "CASCATA POP"
 * - Sfondo immagine (NON modificato) + oggetti che scendono in 5 corsie
 * - Player piccolo in basso: selezionabile via tasti 1/2/3 (bimbo/bimba/coniglio)
 * - Controlli: trascina col dito per spostarti di corsia (o frecce sx/dx)
 * - Buoni: punti, Cattivi: perdi vita
 */

// ====== CONFIG BASE ======
const BG_SRC = "bg.png";      // <-- metti bg.png nella stessa cartella di index.html
const LANES = 5;

const cfg = {
  // prospettiva corsie (convergenza verso l'alto)
  topY: 0.20,           // dove "nascono" gli oggetti (parte bianca in alto)
  bottomY: 0.90,        // dove sta il player
  topSpread: 0.18,      // quanto sono "vicine" le corsie in alto (0.10..0.25)
  bottomLeft: 0.12,     // area pavimento in basso
  bottomRight: 0.88,

  // gameplay
  spawnEveryMs: 650,
  baseSpeed: 0.42,      // più alto = più veloce
  speedRamp: 0.00006,   // aumenta nel tempo (difficoltà)
  goodChance: 0.62,     // % buoni
  lives: 3,

  // hit window vicino al player
  hitT: 0.93,
  hitWindow: 0.055,

  // debug
  debugLanes: false
};

// ====== CANVAS SETUP ======
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

function resize() {
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  canvas.width  = Math.floor(innerWidth * dpr);
  canvas.height = Math.floor(innerHeight * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
addEventListener("resize", resize);
resize();

// ====== UTILS ======
const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const lerp = (a,b,t)=>a+(b-a)*t;
const easeIn = (t)=>t*t;

function laneX(laneIndex, tNorm, w) {
  // tNorm: 0 in alto -> 1 in basso
  const r = (LANES===1) ? 0.5 : laneIndex/(LANES-1);
  const topCenter = 0.5;
  const topLeft  = topCenter - cfg.topSpread/2;
  const topRight = topCenter + cfg.topSpread/2;

  const xTop = lerp(topLeft*w, topRight*w, r);
  const xBot = lerp(cfg.bottomLeft*w, cfg.bottomRight*w, r);
  return lerp(xTop, xBot, tNorm);
}

function yFromT(tNorm, h) {
  // easing per dare feeling "vengono verso di te"
  const t = easeIn(clamp(tNorm, 0, 1));
  return lerp(cfg.topY*h, cfg.bottomY*h, t);
}

function scaleFromT(tNorm) {
  // piccolo in alto, grande in basso
  return lerp(0.35, 1.05, clamp(tNorm,0,1));
}

function nearestLaneAtBottom(x, w) {
  let best = 0, bestD = Infinity;
  for (let i=0;i<LANES;i++) {
    const lx = laneX(i, 1, w);
    const d = Math.abs(x - lx);
    if (d < bestD) { bestD = d; best = i; }
  }
  return best;
}

// ====== ASSETS ======
const bgImg = new Image();
bgImg.src = BG_SRC;
let bgReady = false;
bgImg.onload = ()=> bgReady = true;
bgImg.onerror = ()=> {
  bgReady = false;
  console.warn("Sfondo non trovato. Metti bg.png nella stessa cartella di index.html");
};

// ====== GAME STATE ======
let started = false;
let lastTs = 0;
let elapsed = 0;

const state = {
  score: 0,
  lives: cfg.lives,
  playerLane: 2,
  playerSkin: "bunny", // "boy" | "girl" | "bunny"
  obstacles: [],
  nextSpawn: 0
};

function resetGame() {
  state.score = 0;
  state.lives = cfg.lives;
  state.playerLane = 2;
  state.obstacles = [];
  elapsed = 0;
  lastTs = 0;
  state.nextSpawn = 0;
}

// ====== DRAW HELPERS ======
function drawKawaiiFace(x, y, r) {
  ctx.fillStyle = "rgba(0,0,0,0.85)";
  ctx.beginPath(); ctx.arc(x - r*0.35, y - r*0.10, r*0.10, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(x + r*0.35, y - r*0.10, r*0.10, 0, Math.PI*2); ctx.fill();

  ctx.fillStyle = "rgba(255,255,255,0.9)";
  ctx.beginPath(); ctx.arc(x - r*0.32, y - r*0.14, r*0.04, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(x + r*0.38, y - r*0.14, r*0.04, 0, Math.PI*2); ctx.fill();

  ctx.strokeStyle = "rgba(0,0,0,0.75)";
  ctx.lineWidth = Math.max(1, r*0.06);
  ctx.beginPath();
  ctx.arc(x, y + r*0.08, r*0.18, 0.15*Math.PI, 0.85*Math.PI);
  ctx.stroke();
}
