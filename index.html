<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Cascata POP - Procedural BG</title>
  <style>
    html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#000; touch-action:none; }
    canvas { display:block; width:100vw; height:100vh; }
  </style>
</head>
<body>
<canvas id="c"></canvas>

<script>
/**
 * VERSIONE SENZA IMMAGINI:
 * - Sfondo "simile" generato in codice (raggi, glow, glitter, mattonelle)
 * - 5 corsie + numeri 1..5 sul pavimento
 * - Player (bimbo/bimba/coniglio) in basso
 * - Ostacoli buoni/cattivi che scendono dalla luce in alto
 */

const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

function resize() {
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  canvas.width  = Math.floor(innerWidth * dpr);
  canvas.height = Math.floor(innerHeight * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
addEventListener("resize", resize);
resize();

// ====== CONFIG ======
const LANES = 5;

const cfg = {
  topY: 0.18,        // punto luce (più su = più "uscita" dall'alto)
  bottomY: 0.90,     // player
  topSpread: 0.18,   // corsie strette in alto
  bottomLeft: 0.12,
  bottomRight: 0.88,

  spawnEveryMs: 650,
  baseSpeed: 0.42,
  speedRamp: 0.00006,
  goodChance: 0.62,
  lives: 3,

  hitT: 0.93,
  hitWindow: 0.055,

  // effetto luci/strobo (0..1)
  strobeStrength: 0.22
};

// ====== UTILS ======
const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const lerp = (a,b,t)=>a+(b-a)*t;
const easeIn = (t)=>t*t;

// PRNG deterministico (per glitter sempre uguale)
function mulberry32(seed) {
  let t = seed >>> 0;
  return function() {
    t += 0x6D2B79F5;
    let r = Math.imul(t ^ (t >>> 15), 1 | t);
    r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
    return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
  };
}

function laneX(laneIndex, tNorm, w) {
  const r = (LANES===1) ? 0.5 : laneIndex/(LANES-1);
  const topCenter = 0.5;
  const topLeft  = topCenter - cfg.topSpread/2;
  const topRight = topCenter + cfg.topSpread/2;

  const xTop = lerp(topLeft*w, topRight*w, r);
  const xBot = lerp(cfg.bottomLeft*w, cfg.bottomRight*w, r);
  return lerp(xTop, xBot, tNorm);
}

function yFromT(tNorm, h) {
  const t = easeIn(clamp(tNorm, 0, 1));
  return lerp(cfg.topY*h, cfg.bottomY*h, t);
}

function scaleFromT(tNorm) {
  return lerp(0.35, 1.05, clamp(tNorm,0,1));
}

function nearestLaneAtBottom(x, w) {
  let best = 0, bestD = Infinity;
  for (let i=0;i<LANES;i++) {
    const lx = laneX(i, 1, w);
    const d = Math.abs(x - lx);
    if (d < bestD) { bestD = d; best = i; }
  }
  return best;
}

// ====== BACKGROUND (procedurale) ======
const rnd = mulberry32(123456);
const particles = Array.from({length: 120}, () => ({
  x: rnd(), y: rnd()*0.75, s: 0.6 + rnd()*1.8, a: 0.25 + rnd()*0.55, tw: 0.6 + rnd()*1.4
}));

function drawProceduralBackground(w, h, tSec) {
  // base scura
  ctx.fillStyle = "#090013";
  ctx.fillRect(0,0,w,h);

  const cx = w*0.5;
  const cy = h*cfg.topY;

  // glow principale (bianco/crema)
  {
    const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, Math.max(w,h)*0.55);
    g.addColorStop(0.00, "rgba(255,255,255,0.95)");
    g.addColorStop(0.08, "rgba(255,245,220,0.75)");
    g.addColorStop(0.18, "rgba(255,180,240,0.30)");
    g.addColorStop(0.35, "rgba(90,40,180,0.18)");
    g.addColorStop(1.00, "rgba(0,0,0,0.0)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);
  }

  // raggi colorati
  const beamColors = [
    "rgba(255, 70, 160, 0.22)",
    "rgba(130, 60, 255, 0.22)",
    "rgba(60, 180, 255, 0.22)",
    "rgba(70, 255, 170, 0.20)",
    "rgba(255, 220, 90, 0.18)"
  ];
  const beamCount = 18;
  const spread = Math.PI * 0.78;
  for (let i=0;i<beamCount;i++) {
    const phase = (i/beamCount)*Math.PI*2;
    const wobble = Math.sin(tSec*1.7 + phase)*0.06;
    const ang = -Math.PI/2 + (-spread/2) + (i/(beamCount-1))*spread + wobble;

    const len = h*1.25;
    const x2 = cx + Math.cos(ang)*len;
    const y2 = cy + Math.sin(ang)*len;

    // spessore raggio
    const width = 10 + (i%5)*9;
    const nx = -Math.sin(ang);
    const ny =  Math.cos(ang);

    const aPulse = 0.10 + 0.10*(0.5+0.5*Math.sin(tSec*3.0 + phase));
    const col = beamColors[i % beamColors.length].replace(/0\.\d+\)/, (aPulse + 0.08) + ")");
    ctx.fillStyle = col;

    ctx.beginPath();
    ctx.moveTo(cx + nx*width, cy + ny*width);
    ctx.lineTo(cx - nx*width, cy - ny*width);
    ctx.lineTo(x2 - nx*(width*1.6), y2 - ny*(width*1.6));
    ctx.lineTo(x2 + nx*(width*1.6), y2 + ny*(width*1.6));
    ctx.closePath();
    ctx.fill();
  }

  // glitter/stelle
  for (const p of particles) {
    const tw = 0.5 + 0.5*Math.sin(tSec*p.tw + p.x*10);
    ctx.globalAlpha = p.a * (0.35 + 0.65*tw);
    ctx.fillStyle = "white";
    ctx.beginPath();
    ctx.arc(p.x*w, p.y*h, p.s, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  // disco ball semplici (solo decorazione)
  function discoBall(x, y, r) {
    const g = ctx.createRadialGradient(x-r*0.25, y-r*0.25, 0, x, y, r);
    g.addColorStop(0, "rgba(255,255,255,0.85)");
    g.addColorStop(0.35, "rgba(170,210,255,0.45)");
    g.addColorStop(1, "rgba(0,0,0,0.25)");
    ctx.fillStyle = g;
    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();

    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.lineWidth = 1;
    for (let i=0;i<6;i++){
      const yy = y - r + (2*r/5)*(i);
      ctx.beginPath(); ctx.arc(x,y,Math.abs(yy-y),0,Math.PI*2); ctx.stroke();
    }
  }
  discoBall(w*0.22, h*0.10, Math.min(w,h)*0.055);
  discoBall(w*0.80, h*0.12, Math.min(w,h)*0.045);

  // pavimento mattonelle in prospettiva
  const yTop = h*0.55;
  const yBot = h*1.05;

  // gradiente pavimento
  {
    const g = ctx.createLinearGradient(0, yTop, 0, h);
    g.addColorStop(0, "rgba(20,20,24,0.18)");
    g.addColorStop(0.35, "rgba(25,25,30,0.50)");
    g.addColorStop(1, "rgba(10,10,12,0.95)");
    ctx.fillStyle = g;
    ctx.fillRect(0, yTop, w, h-yTop);
  }

  // linee orizzontali (righe mattonelle)
  ctx.strokeStyle = "rgba(255,255,255,0.12)";
  ctx.lineWidth = 1;
  for (let i=0;i<26;i++){
    const t = i/25;
    const yy = lerp(yTop, yBot, t*t); // più fitte verso l'alto
    ctx.beginPath();
    ctx.moveTo(0, yy);
    ctx.lineTo(w, yy);
    ctx.stroke();
  }

  // linee prospettiche + separatori corsie
  const vanX = cx;
  const vanY = cy + h*0.03;

  // corsie: linee principali
  ctx.strokeStyle = "rgba(255,255,255,0.20)";
  ctx.lineWidth = 2;

  for (let i=0;i<LANES;i++){
    const xBottom = laneX(i, 1, w);
    const xTop = laneX(i, 0, w);
    ctx.beginPath();
    ctx.moveTo(xTop, yFromT(0, h));
    ctx.lineTo(xBottom, h);
    ctx.stroke();
  }

  // numeri 1..5 sul pavimento
  ctx.save();
  ctx.globalAlpha = 0.85;
  ctx.fillStyle = "rgba(255,255,255,0.85)";
  ctx.font = "bold 22px system-ui, -apple-system, Segoe UI, Roboto";
  ctx.textAlign = "center";
  const numY = h*0.965;
  for (let i=0;i<LANES;i++){
    const x = laneX(i, 1, w);
    ctx.fillText(String(i+1), x, numY);
  }
  ctx.restore();

  // strobo soft (non invasivo)
  const st = cfg.strobeStrength;
  if (st > 0) {
    const pulse = 0.5 + 0.5*Math.sin(tSec*7.0);
    ctx.fillStyle = `rgba(255,255,255,${(st*0.18*pulse).toFixed(3)})`;
    ctx.fillRect(0,0,w,h);
  }
}

// ====== GAME STATE ======
let started = false;
let lastTs = 0;
let elapsed = 0;

const state = {
  score: 0,
  lives: cfg.lives,
  playerLane: 2,
  playerSkin: "bunny", // "boy" | "girl" | "bunny"
  obstacles: [],
  nextSpawn: 0
};

function resetGame() {
  state.score = 0;
  state.lives = cfg.lives;
  state.playerLane = 2;
  state.obstacles = [];
  elapsed = 0;
  lastTs = 0;
  state.nextSpawn = 0;
}

// ====== DRAW: player & obstacles ======
function drawKawaiiFace(x, y, r) {
  ctx.fillStyle = "rgba(0,0,0,0.85)";
  ctx.beginPath(); ctx.arc(x - r*0.35, y - r*0.10, r*0.10, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(x + r*0.35, y - r*0.10, r*0.10, 0, Math.PI*2); ctx.fill();

  ctx.fillStyle = "rgba(255,255,255,0.9)";
  ctx.beginPath(); ctx.arc(x - r*0.32, y - r*0.14, r*0.04, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(x + r*0.38, y - r*0.14, r*0.04, 0, Math.PI*2); ctx.fill();

  ctx.strokeStyle = "rgba(0,0,0,0.75)";
  ctx.lineWidth = Math.max(1, r*0.06);
  ctx.beginPath();
  ctx.arc(x, y + r*0.08, r*0.18, 0.15*Math.PI, 0.85*Math.PI);
  ctx.stroke();
}

function drawPlayer(x, y, s, skin) {
  const r = 18 * s;
  ctx.save();
  ctx.translate(x, y);

  if (skin === "boy" || skin === "girl") {
    ctx.fillStyle = "rgba(255,240,220,0.95)";
    ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI*2); ctx.fill();

    ctx.fillStyle = (skin==="girl") ? "rgba(230,200,80,0.95)" : "rgba(120,70,30,0.95)";
    ctx.beginPath(); ctx.arc(0, -r*0.2, r*1.05, Math.PI, 0); ctx.fill();

    ctx.fillStyle = "rgba(60,220,140,0.95)";
    ctx.beginPath(); ctx.arc(-r*1.05, 0, r*0.35, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc( r*1.05, 0, r*0.35, 0, Math.PI*2); ctx.fill();

    ctx.strokeStyle = "rgba(30,30,30,0.7)";
    ctx.lineWidth = Math.max(2, r*0.12);
    ctx.beginPath(); ctx.arc(0, -r*0.65, r*1.1, Math.PI*1.05, Math.PI*1.95); ctx.stroke();

    drawKawaiiFace(0, 2, r*0.95);
  } else {
    ctx.fillStyle = "rgba(255,255,255,0.95)";
    ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI*2); ctx.fill();

    ctx.beginPath(); ctx.ellipse(-r*0.55, -r*1.25, r*0.35, r*0.75, -0.15, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse( r*0.55, -r*1.25, r*0.35, r*0.75,  0.15, 0, Math.PI*2); ctx.fill();

    ctx.fillStyle = "rgba(255,170,190,0.85)";
    ctx.beginPath(); ctx.ellipse(-r*0.55, -r*1.22, r*0.18, r*0.55, -0.15, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse( r*0.55, -r*1.22, r*0.18, r*0.55,  0.15, 0, Math.PI*2); ctx.fill();

    ctx.fillStyle = "rgba(80,180,255,0.95)";
    ctx.beginPath(); ctx.arc(-r*1.00, 0, r*0.32, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc( r*1.00, 0, r*0.32, 0, Math.PI*2); ctx.fill();

    drawKawaiiFace(0, 2, r*0.95);
  }

  ctx.restore();
}

function drawGood(x, y, s) {
  const r = 22 * s;
  ctx.fillStyle = "rgba(255,255,255,0.92)";
  ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = "rgba(255,120,170,0.55)";
  ctx.beginPath(); ctx.arc(x - r*0.5, y + r*0.15, r*0.22, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(x + r*0.5, y + r*0.15, r*0.22, 0, Math.PI*2); ctx.fill();
  drawKawaiiFace(x, y, r);
}

function roundRect(x, y, w, h, r) {
  r = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y, x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x, y+h, r);
  ctx.arcTo(x, y+h, x, y, r);
  ctx.arcTo(x, y, x+w, y, r);
  ctx.closePath();
}

function drawBad(x, y, s) {
  // cubo arrabbiato con cappello + megafono (nessuna arma)
  const size = 44 * s;
  const rr = 10 * s;

  ctx.fillStyle = "rgba(255,200,70,0.95)";
  roundRect(x - size/2, y - size/2, size, size, rr);
  ctx.fill();

  ctx.fillStyle = "rgba(20,20,20,0.85)";
  roundRect(x - size*0.35, y - size*0.68, size*0.7, size*0.22, 6*s);
  ctx.fill();

  ctx.strokeStyle = "rgba(0,0,0,0.8)";
  ctx.lineWidth = Math.max(2, 3*s);
  ctx.beginPath();
  ctx.moveTo(x - size*0.22, y - size*0.12);
  ctx.lineTo(x - size*0.02, y - size*0.22);
  ctx.moveTo(x + size*0.22, y - size*0.12);
  ctx.lineTo(x + size*0.02, y - size*0.22);
  ctx.stroke();

  ctx.fillStyle = "rgba(0,0,0,0.85)";
  ctx.beginPath(); ctx.arc(x - size*0.16, y - size*0.02, 4*s, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(x + size*0.16, y - size*0.02, 4*s, 0, Math.PI*2); ctx.fill();

  ctx.strokeStyle = "rgba(120,0,0,0.85)";
  ctx.lineWidth = Math.max(2, 4*s);
  ctx.beginPath();
  ctx.moveTo(x - size*0.12, y + size*0.15);
  ctx.lineTo(x + size*0.12, y + size*0.15);
  ctx.stroke();

  ctx.fillStyle = "rgba(40,170,255,0.9)";
  ctx.beginPath();
  ctx.moveTo(x + size*0.30, y - size*0.05);
  ctx.lineTo(x + size*0.55, y - size*0.16);
  ctx.lineTo(x + size*0.55, y + size*0.06);
  ctx.closePath();
  ctx.fill();
}

// ====== SPAWN/UPDATE ======
function spawnObstacle() {
  const lane = Math.floor(Math.random() * LANES);
  const isGood = Math.random() < cfg.goodChance;
  state.obstacles.push({ lane, t: 0, kind: isGood ? "good" : "bad", taken: false });
}

function update(dt) {
  elapsed += dt;

  state.nextSpawn -= dt*1000;
  if (state.nextSpawn <= 0) {
    spawnObstacle();
    const jitter = (Math.random()*140 - 70);
    state.nextSpawn = Math.max(260, cfg.spawnEveryMs + jitter);
  }

  const speed = cfg.baseSpeed + elapsed * cfg.speedRamp;
  for (const o of state.obstacles) o.t += dt * speed;

  for (const o of state.obstacles) {
    if (o.taken) continue;
    const near = Math.abs(o.t - cfg.hitT) <= cfg.hitWindow;
    if (!near) continue;

    if (o.lane === state.playerLane) {
      o.taken = true;
      if (o.kind === "good") state.score += 10;
      else {
        state.lives -= 1;
        if (state.lives <= 0) started = false;
      }
    }
  }

  state.obstacles = state.obstacles.filter(o => o.t < 1.15 && !o.taken);
}

// ====== HUD ======
function drawHud() {
  ctx.save();
  ctx.globalAlpha = 0.75;
  ctx.fillStyle = "rgba(0,0,0,0.35)";
  ctx.fillRect(10, 10, 180, 58);
  ctx.globalAlpha = 1;
  ctx.fillStyle = "white";
  ctx.font = "16px system-ui, -apple-system, Segoe UI, Roboto";
  ctx.fillText(`Punti: ${state.score}`, 22, 34);
  ctx.fillText(`Vite: ${"❤".repeat(Math.max(0,state.lives))}`, 22, 54);
  ctx.restore();
}

// ====== LOOP ======
let started = false;
let lastTs = 0;

function render(tSec) {
  const w = innerWidth, h = innerHeight;
  ctx.clearRect(0,0,w,h);

  // sfondo sempre presente
  drawProceduralBackground(w, h, tSec);

  // ostacoli
  for (const o of state.obstacles) {
    const x = laneX(o.lane, o.t, w);
    const y = yFromT(o.t, h);
    const s = scaleFromT(o.t);
    if (o.kind === "good") drawGood(x, y, s);
    else drawBad(x, y, s);
  }

  // player
  const px = laneX(state.playerLane, 1, w);
  const py = yFromT(1, h);
  drawPlayer(px, py, 1.0, state.playerSkin);

  drawHud();

  if (!started) {
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.45)";
    ctx.fillRect(0,0,w,h);
    ctx.fillStyle = "white";
    ctx.font = "22px system-ui, -apple-system, Segoe UI, Roboto";
    ctx.textAlign = "center";
    ctx.fillText(state.lives<=0 ? "GAME OVER - Tocca per ricominciare" : "TOCCA PER INIZIARE", w/2, h*0.45);
    ctx.font = "14px system-ui, -apple-system, Segoe UI, Roboto";
    ctx.fillText("Trascina per cambiare corsia • Tasti 1/2/3 per skin", w/2, h*0.45 + 28);
    ctx.restore();
  }
}

function loop(ts) {
  if (!lastTs) lastTs = ts;
  const dt = Math.min(0.033, (ts - lastTs)/1000);
  lastTs = ts;

  if (started) update(dt);
  render(ts/1000);

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// ====== INPUT ======
let pointerDown = false;

function startOrRestart() {
  if (state.lives <= 0) resetGame();
  started = true;
}

canvas.addEventListener("pointerdown", (e) => {
  pointerDown = true;
  canvas.setPointerCapture?.(e.pointerId);
  if (!started) startOrRestart();
  state.playerLane = nearestLaneAtBottom(e.clientX, innerWidth);
});

canvas.addEventListener("pointermove", (e) => {
  if (!pointerDown || !started) return;
  state.playerLane = nearestLaneAtBottom(e.clientX, innerWidth);
});

canvas.addEventListener("pointerup", () => pointerDown = false);
canvas.addEventListener("pointercancel", () => pointerDown = false);

addEventListener("keydown", (e) => {
  if (e.key === "ArrowLeft") state.playerLane = clamp(state.playerLane - 1, 0, LANES-1);
  if (e.key === "ArrowRight") state.playerLane = clamp(state.playerLane + 1, 0, LANES-1);
  if (e.key === "1") state.playerSkin = "boy";
  if (e.key === "2") state.playerSkin = "girl";
  if (e.key === "3") state.playerSkin = "bunny";
  if (e.key.toLowerCase() === "r") { resetGame(); started = false; }
});
</script>
</body>
</html>
